use std::str::FromStr;

use color::Color;
use direction::Direction;
use lights::Light;
use lights::distant::Distant;
use lights::omni::Omni;
use materials::Material;
use materials::glass::Glass;
use materials::matte::Matte;
use materials::plastic::Plastic;
use matrix::Matrix44f;
use object::Object;
use point::Point;
use sdl;
use sdl::Scene;
use shapes::Shape;
use shapes::plane::Plane;
use shapes::sphere::Sphere;
use system::Camera;
use texture::{Pattern,Texture};

pub scene -> Scene
  = ws* camera:camera ws+ lights:lights ws+ objects:objects ws* {
    Scene {
      camera,
      lights,
      objects,
    }
  }

pub camera -> Camera
  = "camera" ws* "{" ws* loc:location ws+ p:camera_lookat ws* "}" {
    Camera::new(loc, 60.0).look_at(p)
  }

location -> Point
  = "location" ws+ p:point { p }

camera_lookat -> Point
  = "look_at" ws+ p:point { p }

lights -> Vec<Box<Light>>
  = "lights" ws* "{" lights:(light_ws+) "}" {
      lights
  }

light_ws -> Box<Light>
  = ws* light:light ws* { light }

light -> Box<Light>
  = omni_light
  / distant_light

pub omni_light -> Box<Light>
  = "omni" ws* "{" ws* origin:point ws+ color:color ws+ intensity:light_intensity ws* "}" {
    Box::new(Omni {
      color,
      intensity,
      origin,
    })
  }

pub distant_light -> Box<Light>
  = "distant" ws* "{" ws* direction:direction ws+ color:color ws+ intensity:light_intensity ws* "}" {
    Box::new(Distant {
      color,
      intensity,
      direction,
    })
  }

light_intensity -> f64
  = "intensity" ws* i:float { i }

pub objects -> Vec<Object>
  = object ++ (ws+)

pub object -> Object
  = "object"
    ws* "{" ws*
    loc:location
    ws+ shape:object_shape
    ws+ material:object_material
    transform:object_transform_ws?
    ws* "}"
  {
    sdl::new_object(loc, shape, material, transform)
  }

object_shape -> Box<Shape>
  = sphere
  / plane
  / mesh

sphere -> Box<Shape>
  = "sphere" ws* "{" ws* r:sphere_radius ws* "}" {
    Box::new(Sphere::new(r))
  }

sphere_radius -> f64
  = "radius" ws+ r:float { r }

plane -> Box<Shape>
  = "plane" ws* "{" ws* n:plane_normal ws* "}" {
    Box::new(Plane::new(n))
  }

plane_normal -> Direction
  = "normal" ws+ n:direction { n }

mesh -> Box<Shape>
  = "mesh" ws* "{" ws* p:mesh_file ws* "}" {
    sdl::load_mesh_file(&p)
  }

mesh_file -> String
  = "file" ws+ p:path { p }

object_material -> Box<Material>
  = "material" ws* "{" ws* material:material ws* "}" {
    material
  }

material -> Box<Material>
  = matte
  / plastic
  / glass

matte -> Box<Material>
  = "matte" ws+ texture:texture {
    Box::new(Matte::new(texture))
  }

plastic -> Box<Material>
  = "plastic" ws+ texture:texture {
    Box::new(Plastic::new(texture))
  }

glass -> Box<Material>
  = "glass" {
    Box::new(Glass::new())
  }

object_transform_ws -> Matrix44f
  = ws+ t:object_transform { t }

object_transform -> Matrix44f
  = "transform" ws* "{" transforms:transform_ws+ "}" {
    sdl::combine_transforms(transforms)
  }

transform_ws -> Matrix44f
  = ws* t:transform ws* { t }

transform -> Matrix44f
  = translate
  / rotate
  / scale

translate -> Matrix44f
  = "translate" ws+ d:direction {
    Matrix44f::translation(d)
  }

rotate -> Matrix44f
  = rotate_x
  / rotate_y
  / rotate_z

rotate_x -> Matrix44f
  = "rotate_x" ws+ n:float {
    Matrix44f::rotation_x(n)
  }

rotate_y -> Matrix44f
  = "rotate_y" ws+ n:float {
    Matrix44f::rotation_y(n)
  }

rotate_z -> Matrix44f
  = "rotate_z" ws+ n:float {
    Matrix44f::rotation_z(n)
  }

scale -> Matrix44f
  = "scale" ws+ d:direction {
    Matrix44f::scaling(d)
  }

/*
object_shader -> (f64, Shader)
  = f:float ws+ t:shader_type { (f, t) }

shader_type -> Shader
  = diffuse_specular
  / reflection
  / transparency

diffuse_specular -> Shader
  = "diffuse_specular" ws* "{" ws* texture:texture ws+ roughness:roughness ws+ highlight:highlight ws* "}" {
    Shader::DiffuseSpecular {
      albedo: DEFAULT_ALBEDO,
      texture,
      roughness,
      highlight,
    }
  }

reflection -> Shader
  = "reflection" {
    Shader::Reflection
  }

transparency -> Shader
  = "transparency" ws* "{" ws* ior:ior ws* "}" {
    Shader::Transparency { ior }
  }

ior -> f64
  = "ior" ws+ n:float { n }
*/

texture -> Texture
  = "texture" ws* "{" ws* t:(texture_solid / texture_pattern / texture_image) ws* "}" { t }

texture_solid -> Texture
  = "solid" ws+ c:color {
    Texture::Solid(c)
  }

texture_pattern -> Texture
  = "pattern" ws* "{" ws* p:pattern_checkerboard ws* "}" { Texture::Pattern(p) }

pattern_checkerboard -> Pattern
  = "checkerboard" ws+ c1:color ws+ c2:color ws+ s:float {
    Pattern::Checkerboard(c1, c2, s)
  }

texture_image -> Texture
  = "image" ws+ p:path ws+ s:float {
    Texture::Image(sdl::load_image(&p), s)
  }

path -> String
  = "\"" s:$([^"]*) "\"" { String::from_str(s).unwrap() }

roughness -> f64
  = "roughness" ws+ n:float { n }

highlight -> f64
  = "highlight" ws+ n:float { n }

pub point -> Point
  = v:vec3 { Point::new(v.0, v.1, v.2) }

pub direction -> Direction
  = v:vec3 { Direction::new(v.0, v.1, v.2) }

pub color -> Color
  = ("color"/"colour") ws* c:(std_color / rgb_color) { Color::new(c.0, c.1, c.2) }

std_color -> (f64, f64, f64)
  = "white"   { (1.0, 1.0, 1.0) }
  / "black"   { (0.0, 0.0, 0.0) }
  / "red"     { (1.0, 0.0, 0.0) }
  / "green"   { (0.0, 1.0, 0.0) }
  / "blue"    { (0.0, 0.0, 1.0) }
  / "yellow"  { (1.0, 1.0, 0.0) }
  / "cyan"    { (0.0, 1.0, 1.0) }
  / "magenta" { (1.0, 0.0, 1.0) }

rgb_color -> (f64, f64, f64)
  = "rgb" ws* v:vec3 { v }

pub vec3 -> (f64, f64, f64)
  = "<" ws* a:float ws* "," ws* b:float ws* "," ws* c: float ws* ">" { (a, b, c) }

pub float -> f64
  = #quiet<s:$("-"?([0-9]+)("."[0-9]+([eE][0-9]+)?)?) { f64::from_str(s).unwrap() }>
  / #expected("float")

pub uint -> u64
  = #quiet<s:$([0-9]+) { u64::from_str(s).unwrap() }>
  / #expected("int")

comma_sep
  = ws* "," ws*

ws = #quiet<[ \n\r\t]>
